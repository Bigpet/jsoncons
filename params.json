{"name":"jsoncons","tagline":"C++ library for parsing and serializing JSON text","body":"# jsoncons: a C++ library for json construction\r\n\r\njsoncons is a C++ library for the construction of [JavaScript Object Notation (JSON)](http://www.json.org). It supports parsing a JSON file or string into a `json` value, building a `json` value in C++ code, and serializing a `json` value to a file or string. It also provides an event-based API for reading and writing JSON documents that are too large to fit into available memory, somewhat analogously to SAX processing in the XML world. Consult the wiki for the latest [documentation and tutorials](https://github.com/danielaparker/jsoncons/wiki) and [roadmap](https://github.com/danielaparker/jsoncons/wiki/Roadmap). \r\n\r\njsoncons uses some features that are new to C++ 11, particularly move semantics, however, it has been written to be compatible with VC++ 10 SP1. It has been tested with MS Visual C++ 10 SP1, Visual Studio 2015, clang 3.3 and GCC 4.8. \r\n\r\n## Using the jsoncons library\r\n\r\nThe jsoncons library is header-only: it consists solely of header files containing templates and inline functions, and requires no separately-compiled library binaries when linking. It has no dependence on other libraries. \r\n\r\nTo install the jsoncons library, download the zip file, extract the zipped files, find the directory `jsoncons` under `src`, and copy it to your `include` directory. If you wish to use extensions, copy the `jsoncons_ext` directory as well. \r\n\r\nThe jsoncons classes and functions are in namespace `jsoncons`. You need to include the header file\r\n \r\n    #include \"jsoncons/json.hpp\"\r\n\r\nand, for convenience, you can add a few using declarations\r\n\r\n    using jsoncons::json;\r\n    using jsoncons::json_deserializer;\r\n\r\n### Reading JSON text from a file\r\n\r\nHere is a sample file (books.json):\r\n\r\n    [\r\n        {\r\n            \"title\" : \"Kafka on the Shore\",\r\n            \"author\" : \"Haruki Murakami\",\r\n            \"price\" : 25.17\r\n        },\r\n        {\r\n            \"title\" : \"Women: A Novel\",\r\n            \"author\" : \"Charles Bukowski\",\r\n            \"price\" : 12.00\r\n        },\r\n        {\r\n            \"title\" : \"Cutter's Way\",\r\n            \"author\" : \"Ivan Passer\"\r\n        }\r\n    ]\r\n\r\nYou can read the JSON text into a `json` value like this\r\n\r\n    json books = json::parse_file(\"books.json\");\r\n\r\nYou can then loop through the books\r\n\r\n    for (size_t i = 0; i < books.size(); ++i)\r\n    {\r\n        try\r\n        {\r\n            json& book = books[i];\r\n            std::string author = book[\"author\"].as<std::string>();\r\n            std::string title = book[\"title\"].as<std::string>();\r\n            double price = book[\"price\"].as<double>();\r\n            std::cout << author << \", \" << title << \", \" << price << std::endl;\r\n        }\r\n        catch (const json_exception& e)\r\n        {\r\n            std::cerr << e.what() << std::endl;\r\n        }\r\n    }\r\n\r\nThe output is\r\n\r\n    Haruki Murakami, Kafka on the Shore, 25.17\r\n    Charles Bukowski, Women: A Novel, 12\r\n    Member price not found.\r\n\r\nNote that the third book is missing a price, which causes an exception to be thrown.\r\n\r\nYou have a choice of accessors:\r\n\r\n    book[\"price\"] will throw if there is no price\r\n    book.get(\"price\") will return a json null value if there is no price\r\n    book.get(\"price\",default_value) will return default_value if there is no price\r\n\r\nSo if you want to show \"n/a\" for the missing price, you can use this accessor\r\n\r\n    std::string price = book.get(\"price\",\"n/a\").as<std::string>();\r\n\r\nand the output becomes\r\n\r\n    Haruki Murakami, Kafka on the Shore, 25.17\r\n    Charles Bukowski, Women: A Novel, 12.0\r\n    Ivan Passer, Cutter's Way, n/a\r\n\r\nOr you can check if book has a member \"price\" with the method `has_member`, and output accordingly,\r\n\r\n    if (book.has_member(\"price\"))\r\n    {\r\n        double price = book[\"price\"].as<double>();\r\n        std::cout << price;\r\n    }\r\n    else\r\n    {\r\n        std::cout << \"n/a\";\r\n    }\r\n\r\n### Constructing json values in C++\r\n\r\nTo construct an empty json object, use the default constructor:\r\n\r\n     json image_sizing;\r\n\r\nSerializing it to standard out\r\n\r\n    std::cout << image_sizing << std::endl;\r\n\r\nproduces\r\n\r\n    {}\r\n\r\nAdding some members,\r\n\r\n    image_sizing[\"resize_to_fit\"] = true;  // a boolean \r\n    image_sizing[\"resize_unit\"] =  \"pixels\";  // a string\r\n    image_sizing[\"resize_what\"] =  \"long_edge\";  // a string\r\n    image_sizing[\"dimension1\"] = 9.84;  // a double\r\n    image_sizing[\"dimension2\"] = json::null_type();  // a null\r\n\r\nSerializing it, this time with pretty print,\r\n\r\n \tstd::cout << pretty_print(image_sizing) << std::endl;\r\n\r\nproduces\r\n\r\n    {\r\n        \"dimension1\":9.84,\r\n        \"dimension2\":null,\r\n        \"resize_to_fit\":true,\r\n        \"resize_unit\":\"pixels\",\r\n        \"resize_what\":\"long_edge\"\r\n    }\r\n\r\nTo construct a json array, use the array type default constructor:\r\n\r\n    json image_formats = json::array();\r\n\r\nAdding some elements,\r\n\r\n    image_formats.add(\"JPEG\");\r\n    image_formats.add(\"PSD\");\r\n    image_formats.add(\"TIFF\");\r\n    image_formats.add(\"DNG\");\r\n\r\nCombining the two\r\n\r\n    json file_export;\r\n    file_export[\"image_formats\"] = std::move(image_formats);\r\n    file_export[\"image_sizing\"] = std::move(image_sizing);\r\n\r\nand serializing\r\n\r\n    std::cout << pretty_print(file_export) << std::endl;\r\nproduces\r\n\r\n    {\r\n        \"image_formats\":\r\n        [\"JPEG\",\"PSD\",\"TIFF\",\"DNG\"],\r\n        \"image_sizing\":\r\n        {\r\n            \"dimension1\":9.84,\r\n            \"dimension2\":null,\r\n            \"resize_to_fit\":true,\r\n            \"resize_unit\":\"pixels\",\r\n            \"resize_what\":\"long_edge\"\r\n        }\r\n    }\r\n\r\n### Converting CSV files to json\r\n\r\nHere is a sample CSV file (tasks.csv):\r\n\r\n    project_id, task_name, task_start, task_finish\r\n    4001,task1,01/01/2003,01/31/2003\r\n    4001,task2,02/01/2003,02/28/2003\r\n    4001,task3,03/01/2003,03/31/2003\r\n    4002,task1,04/01/2003,04/30/2003\r\n    4002,task2,05/01/2003,\r\n\r\nYou can read the `CSV` file into a `json` value with the `csv_reader`.\r\n\r\n    #include \"jsoncons_ext/csv/csv_reader.hpp\"\r\n\r\n    using jsoncons::csv::csv_parameters;\r\n    using jsoncons::csv::csv_reader;\r\n\r\n    std::fstream is(\"tasks.csv\");\r\n\r\n    json_deserializer handler;\r\n\r\n    csv_parameters params;\r\n    params.assume_header(true);\r\n    params.trim(true);\r\n    params.ignore_empty_values(true);\r\n    params.data_types(\"integer,string,string,string\");\r\n\r\n    csv_reader reader(is,handler,params);\r\n    reader.read();\r\n    json val = handler.get_result();\r\n\r\n    std::cout << pretty_print(val) << std::endl;\r\n\r\nThe output is:\r\n\r\n    [\r\n        {\r\n            \"project_id\":4001,\r\n            \"task_finish\":\"01/31/2003\",\r\n            \"task_name\":\"task1\",\r\n            \"task_start\":\"01/01/2003\"\r\n        },\r\n        {\r\n            \"project_id\":4001,\r\n            \"task_finish\":\"02/28/2003\",\r\n            \"task_name\":\"task2\",\r\n            \"task_start\":\"02/01/2003\"\r\n        },\r\n        {\r\n            \"project_id\":4001,\r\n            \"task_finish\":\"03/31/2003\",\r\n            \"task_name\":\"task3\",\r\n            \"task_start\":\"03/01/2003\"\r\n        },\r\n        {\r\n            \"project_id\":4002,\r\n            \"task_finish\":\"04/30/2003\",\r\n            \"task_name\":\"task1\",\r\n            \"task_start\":\"04/01/2003\"\r\n        },\r\n        {\r\n            \"project_id\":4002,\r\n            \"task_name\":\"task2\",\r\n            \"task_start\":\"05/01/2003\"\r\n        }\r\n    ]\r\n\r\nThere are a few things to note about the effect of the parameter settings.\r\n- `assume_header` `true` tells the csv parser to parse the first line of the file for column names, which become object member names.\r\n- `trim` `true` tells the parser to trim leading and trailing whitespace, in particular, to remove the leading whitespace in the column names.\r\n- `ignore_empty_values` `true` causes the empty last value in the `task_finish` column to be omitted.\r\n- The `data_types` setting specifies that column one (\"project_id\") contains integers and the remaining columns strings.\r\n\r\n### Iterators\r\n\r\n`jsoncons::json` supports iterators for accessing the members of json objects and the elements of json arrays.\r\n\r\nAn example of iterating over the name-value pairs of a json object:\r\n\r\n    json person;\r\n    person[\"first_name\"] = \"Jane\";\r\n    person[\"last_name\"] = \"Roe\";\r\n    person[\"events_attended\"] = 10;\r\n    person[\"accept_waiver_of_liability\"] = true;\r\n\r\n    for (auto it = person.begin_members(); it != person.end_members(); ++it)\r\n    {\r\n        std::cout << \"name=\" << it->name() \r\n                  << \", value=\" << it->value().as<std::string>() << std::endl;\r\n    }\r\n\r\nAn example of iterating over the elements of a json array:\r\n\r\n    json cities= json::array();\r\n    cities.add(\"Montreal\");\r\n    cities.add(\"Toronto\");\r\n    cities.add(\"Ottawa\");\r\n    cities.add(\"Vancouver\");\r\n\r\n    for (auto it = cities.begin_elements(); it != cities.end_elements(); ++it)\r\n    {\r\n        std::cout << it->as<std::string>() << std::endl;\r\n    }\r\n\r\n### jsonpath\r\n\r\n[Stefan Goessner's JsonPath](http://goessner.net/articles/JsonPath/) is an XPATH inspired query language for selecting parts of a JSON structure.\r\n\r\nHere is a sample JSON file (store.json):\r\n\r\n    { \"store\": {\r\n        \"book\": [ \r\n          { \"category\": \"reference\",\r\n            \"author\": \"Nigel Rees\",\r\n            \"title\": \"Sayings of the Century\",\r\n            \"price\": 8.95\r\n          },\r\n          { \"category\": \"fiction\",\r\n            \"author\": \"Evelyn Waugh\",\r\n            \"title\": \"Sword of Honour\",\r\n            \"price\": 12.99\r\n          },\r\n          { \"category\": \"fiction\",\r\n            \"author\": \"Herman Melville\",\r\n            \"title\": \"Moby Dick\",\r\n            \"isbn\": \"0-553-21311-3\",\r\n            \"price\": 8.99\r\n          }\r\n        ],\r\n      }\r\n    }\r\n\r\nThe following code returns all authors whose books are cheaper than $10. \r\n    \r\n    #include \"jsoncons_ext/jsonpath/json_query.hpp\"\r\n\r\n    using jsoncons::jsonpath::json_query;\r\n\r\n    json root = json::parse_file(\"store.json\");\r\n\r\n    json result = json_query(root,\"$.store.book[?(@.price < 10)].author\");\r\n\r\n    std::cout << pretty_print(result) << std::endl;\r\n\r\nThe result is\r\n\r\n    [\"Nigel Rees\",\"Herman Melville\"]\r\n\r\n### About jsoncons::json\r\n\r\nThe json class is an instantiation of the `basic_json` class template that uses `char` as the character type\r\nand `std::allocator<void>` as the allocator type,\r\n\r\n    typedef basic_json<char,std::allocator<void>> json\r\n\r\nThe library includes an instantiation for wide characters as well,\r\n\r\n    typedef basic_json<wchar_t,std::allocator<void>> wjson\r\n\r\nNote that the allocator type allows you to supply a custom allocator for dynamically allocated, \r\nfixed size small objects in the json container, the container rebinds it as necessay. \r\nFor instance, you can use the boost `fast_pool_allocator`:\r\n\r\n    #include <boost/pool/pool_alloc.hpp>\r\n    #include \"jsoncons/json.hpp\"\r\n\r\n    typedef jsoncons::basic_json<char, boost::fast_pool_allocator<void>> myjson;\r\n\r\n    myjson o;\r\n\r\n    o.set(\"FirstName\",\"Joe\");\r\n    o.set(\"LastName\",\"Smith\");\r\n\r\nThis results in a json object instance being allocated from the boost memory pool. \r\nThe allocator type is not used for structures including vectors and strings that use large or variable amounts of memory, \r\nthese always use the default allocators.\r\n\r\n## Wide character support\r\n\r\njsoncons supports wide character strings and streams with `wjson` and `wjson_reader`. It supports `UTF16` encoding if `wchar_t` has size 2 (Windows) and `UTF32` encoding if `wchar_t` has size 4. You can construct a `wjson` value in exactly the same way as a `json` value, for instance:\r\n\r\n    using jsoncons::wjson;\r\n\r\n    wjson root;\r\n    root[L\"field1\"] = L\"test\";\r\n    root[L\"field2\"] = 3.9;\r\n    root[L\"field3\"] = true;\r\n\r\n    std::wcout << root << L\"\\n\";\r\n\r\nwhich prints\r\n\r\n    {\"field1\":\"test\",\"field2\":3.9,\"field3\":true}\r\n\r\n### Type extensibility\r\n\r\nIn the json class, constructors, accessors and modifiers are templated, for example,\r\n\r\n    template <typename T>\r\n    explicit json(T val)\r\n\r\n    template<typename T>\r\n    bool is() const\r\n\r\n    template<typename T>\r\n    T as() const\r\n\r\n    template <typename T>\r\n    basic_json& operator=(T val)\r\n\r\n    template <typename T>\r\n    void add(T val)\r\n\r\nThe implementations of these functions and operators make use of the class template `json_type_traits`\r\n\r\n    template <typename Char, typename Alloc, typename T>\r\n    class json_type_traits\r\n    {\r\n    public:\r\n        static bool is(const basic_json<Char,Alloc>&);\r\n        static T as(const basic_json<Char,Alloc>& val);\r\n        static void assign(basic_json<Char,Alloc>& lhs, T rhs);\r\n    };\r\n\r\nThis class template is extensible, you as a user can extend `json_type_traits` in the `jsoncons` namespace with your own types. You can, for example, extend `json_type_traits` to access and modify `json` structures with `boost::gregorian::date values`, and in your code, write\r\n\r\n    json deal;\r\n    deal[\"maturity\"] = boost::gregorian::date(2015,1,1);\r\n\t\r\n    json observation_dates = json::array();\r\n    observation_dates.add(boost::gregorian::date(2013,10,21));\r\n    observation_dates.add(boost::gregorian::date(2013,10,28));\r\n    deal[\"observation_dates\"] = std::move(observation_dates);\r\n\t\r\n    boost::gregorian::date maturity = deal[\"maturity\"].as<boost::gregorian::date>();\r\n\t\r\n    std::cout << deal << std::endl;\t\r\n\r\nproducing\r\n\r\n    {\r\n        \"maturity\":\"2015-01-01\",\r\n        \"observation_dates\":\r\n        [\"2013-10-21\",\"2013-10-28\"]\r\n    }\r\n\r\n### json any\r\n\r\njsoncons provides a class `json::any` that can contain a value of any type as long as that type supports copy construction and \r\nassignment. This allows you to, for example, insert a boost matrix into a `json` object, and to retrieve it back cast to the appropriate type. You can do so by wrapping it in\r\na `json::any` value, like this:\r\n\r\n    #include <boost/numeric/ublas/matrix.hpp>\r\n\r\n    using boost::numeric::ublas::matrix;\r\n\r\n    json val;\r\n\r\n    matrix<double> A(2,2);\r\n    A(0,0) = 1;\r\n    A(0,1) = 2;\r\n    A(1,0) = 3;\r\n    A(1,1) = 4;\r\n\r\n    val.set(\"A\",json::any(A));\r\n\r\n    matrix<double>& B = val[\"A\"].any_cast<matrix<double>>();\r\n\r\nBy default, if you print `val` on a stream, \r\n\r\n    std::cout << pretty_print(val) << std::endl;\r\n\r\nthe template function\r\n\r\n    template <typename Char,class T> inline\r\n    void serialize(basic_json_output_handler<Char>& os, const T&)\r\n    {\r\n        os.value(null_type());\r\n    }\r\n\r\ngets called, and produces a `null` value for the matrix. You can however introduce a specialization of `serialize` for `boost::numeric::ublas::matrix` in the `jsoncons` namespace, to produce the output \r\n\r\n    {\r\n        \"A\":\r\n        [\r\n            [1,2],\r\n            [3,4]\r\n        ]\r\n    }\r\n","google":"UA-42023908-1","note":"Don't delete this file! It's used internally to help with page regeneration."}